Part 0 – Intro and setup


(A) - INTRO

Welcome to the RapidApp "Chinook" demo.

In this demo video we're going to build a new webapp from scratch, step by step, using RapidApp, with the "Chinook" sample database for the backend

We're going to build a Database-driven application, using the "RapidDbic" plugin, which is a component of RapidApp that provides out-of-the box front-ends for DBIx colon-colon Class, or "DBIC" for short. 

RapidDbic essentially auto-configures other RapidApp modules, which as we'll see, sets up grid and page views for DBIC Sources, proving CRUD, interactive query builders, customizable views, and so on…

For this demo, as I mentioned, we're going to use the Chinook sample database. Chinook is a freely available sample data model, with some nice sample data. It provides multiple tables with various types columns, indexes, relationships, foreign-key constraints, and so on. The purpose of Chinook is exactly for the type of demo we're doing in this video, showcasing the common use-cases for relational databases…


All steps will be performed live/real-world within this shell, which is an SSH session on an ordinary Linux box.

We will test as we go, and demonstrate the features and functionality in Firefox.

But all commands and changes will be done in this command shell and recorded with Git, and since you are already in the future, it is available on Github at the url shown…

I'm also recording the full command history - which is what is on the screen now, and is both the live commands being run, as well as serving the function of slides for this video


This video does assume the viewer has some prior knowledge. To get the most out of this video you should already know about

Perl and CPAN.

Catalyst, since RapidApp is an extension to Catalyst, which is what we'll be working in.

DBIC, and relational database concepts in general

Git, just so you can follow along in the repo and download the code we'll be building

And finally, Linux and bash just since that is the environment we're working in, within the command shell.

If you're not up to speed on all these topics, don't worry, you can still follow along and learn as you go, and there are plenty of resources available online. This video is designed to make following along as easy as possible, with every command and change recorded….



(B) - APP/GIT SETUP

So, first things first, we need to download and install the latest RapidApp from CPAN. 

As you can see, I already have RapidApp on my system, but if I didn't, it would have been automatically installed, along with all its dependencies, including Catalyst.

If you don't have cpanm, you need to install cpanminus. Cpanminus is a handy tool for installing CPAN packages with dependencies without all the fuss and setup required for the traditional cpan client.


Next, we need to create the new Catalyst application using the helper script provided by Catalyst. The app could be named anything, but I'm going to call it RA::ChinookDemo.

The catalyst.pl helper script has now created a skeleton of base files and directories which will be working in moving forward.

The first thing we're going to do is setup the git repository to track our changes.

I'm also going to setup a simple bash alias to automate committing changes going forward.

So when we type Commit with a capital C, it will automatically:
* Write outstanding commands to the history file
* And copy it to cmd_history.sh
* Add all changes to the git index
* And commit those changes with the supplied commit message

Now, we'll use this new command to record our first commit.

again, this is the repository that is available on github. I'll push it at the end of the video. 



Now we need to download the actual Chinook database

Chinook is available in multiple database formats, and DBIC supports multiple formats, but we'll be using SQLite for this demo.

I would have done this with wget in the shell, but unfortunately their site doesn't support direct download links. So, instead I've just already downloaded and extracted this zip file into the parent directory of our app.

We're going to use the basic sql file which includes both the DDL, or schema, and the sample data.

As you can see, this file is about 1.8 megs.

Now, I'm going to use it to create a new SQLite database, chinook.db in the current directory. This process takes a little while, about 10 minutes. Just for fun, let's run the command through time to see how long it actually takes

Note that this is error is safe to ignore; it's just caused by the Unicode BOM, or byte order mark, that the Chinook people have put at the start of the sql file. I could have removed it, but it doesn't hurt anything.

Now let's fast-forward to the future. 

The command finished and ended up taking just over 8 minutes. 

Let's go ahead and commit our progress



Now we're going to create a Catalyst DBIC Schema Model for our new database using the helper script. Under the hood this uses DBIC's Schema::Loader to automatically generate schema and result classes based on the database we just created.

* We're creating a new model called 'DB', which is just the name I picked, it could be anything
* based on DBIC::Schema, which tells Catalyst which helper to use
* using this for the DBIC schema namespace
* And now we'll set some Schema::Loader options, creating the result classes one time, statically, and also turning off POD generation in the created files
* Now comes the DSN string, which we're pointing at our SQLite database file
* And finally, we'll set some connect_info options, such as enabling Unicode
*  and setting quote_names, which is required for RapidApp

For more info on this command and the available options, see the DBIC::Schema helper docs on CPAN

Now we'll commit the changes, which shows the files that were just created. 

These include the DBIC Schema and 11 result classes for each of the tables in the Chinook database, and the Catalyst Model, which links to them


Part 1 - RapidDbic


RECAP

To recap what's been done so far:

* We've created a standard skeleton Catalyst app,
*  setup SQLite with the Chinook sample database
*  and created an associated DBIC Schema and model
* We've been tracking our changes with git,
*  and the repo is on Github,
*  and we've also been using a custom shell alias, Commit with a capital C, to record notes and command history as we go, which is in the file cmd_history.sh

As you can see we've made 3 commits so far. I'm making another now, with a tag, so it is easy to jump back to this spot.

Up until now this has been out-of-the-box Catalyst. Now we're going to enable RapidApp and load the RapidDbic plugin for web access to our SQLite database. This is done in the main application class, ChinookDemo.pm

This is the boiler-plate application class content. I'm removing these comments to make the file more concise. 

To enable RapidApp, simply use it.

RapidApp doesn't do anything by itself, but makes other modules and plugins available. For this demo we're going to be using RapidDbic, so we just need to load it, like any Cayalyst plugin.

I'm removing these other plugins just because we're not going to be using them. However, it wouldn't break anything if I left them. And we'll go ahead and leave -Debug on for now.

Now we need to configure RapidDbic, which is done in the standard manner in the Catalyst config. 

There are many available options, but the only one that is required is the list of DBIC::Schema models to use. 

And we'll specify the model we already setup with the Chinook sample database, which we named 'DB'.

That's all that's needed for the base setup, so we'll save and exit.

We need to do one last thing before we can start using the app, which is to remove the auto-created Root controller that displays the catalyst welcome screen. We need to do this because locally defined controllers always get precedence. The default Root controller is just a placeholder, anyway.

Now let's start the app using the test server:

Since we left -Debug mode on, various console messages are shown. The cyan lines show RapidApp modules being loaded. RapidDbic is actually just a config wrapper; under the hood it sets up and configures the real RapidApp modules that do the heavy lifting.

Now that the app has started, let's fire up a browser and have a look


*** BROWSER DEMO ***

Out of the box, RapidDbic sets up a TabGui interface, which is a general-purpose UI provided by RapidApp, and is used by other modules as well. It consists of an ExtJS viewport with a navigation tree and tabbed content panel. RapidDbic sets up menu points for each database table, which open in grid views.

The interface is all AJAX, so there are no browser page loads, but the tabs are still tied to real URLs, which are restful and absolute so they can be linked to or typed directly. Browser history is also integrated so the forward and back buttons work as expected without navigating away from the app.

You can close tabs individually, or all but one from the right-click context menu.

You can resize the navtree by clicking and dragging, or hide it, toggle it, unhide it again, and so on.

This is very much like a desktop database admin utility, but keep in mind this is just a base which is designed to be extended into custom applications of all shapes and sizes.

But before we get ahead of ourselves, let's explore some of the out-of-the-box features already provided by these grid views



COLUMNS

Columns can be sorted, resized, and reordered with drag and drop, as well as enabled or disabled from the column menu, either individually, or toggled all at once. 

Rows can also be opened in their own view by double-clicking. The default row page is also a generic property grid, but custom layouts and interfaces are supported.

For clients that can't double-click, like tablets, you can also single click on the special Open Item Column to open the row.

The grid is paginated with standard paging controls in the toolbar, including page forward, page backward, … first page, last page,  …. And setting the items per page.

Also notice that the sort applies to the entire set rather than the current page.

The total row count is shown as well as the range of the current page.

There is also a refresh button to reload the current page, and the most recent query time is also shown. This displays 1 or 2 numbers. The first number is the query time for the current page, and the second number, if present, is the query time of the total count, which isn't fetched every time for speed.


FILTERS


We're currently working with a very small data set, so the queries are only taking a few milliseconds. But with larger tables this feedback can be very helpful, especially when dealing with  custom queries, which you can setup interactively by clicking the Filters button in the lower-right corner.

Here you can add conditions consisting of a column, a type, and a value.

Multiple conditions can be setup using ANDs and ORs. You can also type to filter the list when selecting a column.

Now the only rows shown are those with country equal to USA or France.

Whenever filters are active, a green pencil in shown within the button, as well as the number of conditions.

Multiple types of conditions are supported, including special kinds, like matching on nulls and empty strings.

Conditions can also be grouped and nested.

These sets of conditions are equivalent to parenthesis which let you define the precedence of ands and ors.

You can build as many conditions and levels as you want. 

You can also move the order of items up and down with the arrow buttons, and items are removed with the X button.


QUICK SEARCH

There is also a simple text box in the top toolbar for quick searching. By default, it simply returns rows with any column containing the search string.  

With the alternate "Exact" mode, whole columns are matched instead of substrings, which is faster for obvious reasons.

Now no rows are returned since no columns are exactly equal to US. 

But, there are some exact matches for USA 

You can also choose which columns to search

The text in the heading is determined by the selected mode and search columns. Here we're searching for an exact match on city only, and since there are no cities named 'USA' there are no rows found.   

But, if we type in London, those two matching rows are displayed. 

The search is launched by hitting enter or clicking the magnify button, and cleared by clicking the X button.


SEARCHING NUMBERS AND DATES

So far our examples have only involved text columns, but the since system understands the database schema, it is able to provide different interfaces for different column types, automatically. 

For instance, the Invoice table has some other types of columns,    including a datetime column, and a numeric decimal column.

So when we setup a filter on total, for example, since the system knows it's numeric, only appropriate, number-based conditions are shown.

The value box also restricts and validates for numeric input, so for example it won't let you type in letters, only valid numbers.

There is also very robust support for dates and times. 

The condition choices are date-specific, and the value input automatically provides a date selector.


You can select or supply a specific date, like we just did, or you can enter a relative date, which is a text-based duration string with a flexible, human-readable format.

The input dialog provides a quick reference with examples.

For instance, we can enter minus 5 months, which translates into April 12th, which is "relative" to the current date and time, which as I am recording is September 12th at 3:36PM. 

So, this filter will show all invoices with a total greater than 10 over the past 5 months.

The format is very flexible. It understands all the major English time units from weeks months and years down to hours minutes and seconds. It also supports combinations.

You can type in whole words or use abbreviations. Whitespace is ignored. 

The effective date and time is shown in real time as you type, and you also know right away if what you've entered is invalid. This instant feedback makes it easy to use and understand, despite its flexibility and dynamic syntax

The dialog box is just a helper. Once you get the hang of the format you can just type in values directly. You won't see the real-time effective date, but invalid entries are still shown in red.

The offset string is relative to the current date and time by default, but you can supply different relative starting points like this month, this year, this quarter, and so on.

So, this quarter, minus 1 quarter, would be the first day of last quarter, or midnight on april 1st. A relative date just translates into a normal date, which is a single point in time. But if we add a 'before' condition to go with our 'after' condition, we can define a range, … in this case, the 3 month span between the start and the end of last quarter, which is currently the beginning of april through the end of june.

If we save this filter we can now see that there were 3 invoices last quarter that were greater than 10. And if we remove the total condition we can see there were 18 in all. 

One of the benefits of relative dates over manually dates, besides being faster and needing less thinking, is that they move forward with time. So, if we saved this view and came back to it later, the results would change according to the current date, it would always be "last quarter", instead of april through june 2013. In February 2015, for example, it would show invoices from October through December 2014

I'll be covering saved views a little later in the video.


COLUMN SUMMARIES

Another handy out-of-the-box feature are 'column summaries', which provide aggregate functions for calculations on the current set of rows. 

Sticking with the same relative date range filter, with this column summary we can see that the invoice total from last quarter, or the total of totals, was 104.94.

Like the filter interfaces, column summaries are based on the underlying schema and column types, so text columns, like billingcountry, list different functions than number columns, like total.

Now we can see that the average invoice last quarter was 5  83, and there were 11 unique countries.


RELATIONSHIP COLUMNS

Besides understanding the column types of the schema, which is relatively simple, the system also understands the underlying inter-table relationships, and foreign key constraints.

You may have noticed the little magnifying glass icons next to the values in certain columns. These are displayed within "relationship" columns and are clickable links to the related data.

In this case, customerid is a foreign key which links each invoice row to a specific customer row which the link will open in a tab.

Customer id is a single relationship, or a "belongs_to", because you can imagine that each invoice 'belongs to' a given customer.

The other side of this single relationship – that is, from the perspective of the customer table – is a multi relationship, or a "has_many", because a given customer can be thought to "have many" invoices.

The invoice table has a multi relationship of its own, invoice_lines, because an invoice "has_many" lines.

Multi-relationship columns display a count of the related rows, and the link opens to a list of those rows, rather than a specific row as with a single relationship, like customerid

These are column representations of the relationships defined in the associated DBIC result class, or source. 

The customerid column is both a relationship name and also a physical column in the table, however the multi relationship column 'invoice_lines' is virtual.

Relationship columns are still considered "local" to the given source in which they are defined. Related, or joined columns, on the other hand, are columns from other tables that have been joined into the local view.

Joined columns aren't configured automatically out-of-the-box because there are lots of possible configurations. You just need to tell the system which columns you want, in what sources, in the RapidDbic config.



JOINED COLUMNS

First let's commit our changes so far, and then edit the main application class some more.

The settings for each DBIC Schema are defined in the hashkey of the model name, under the configs key. In our example we have only one schema model, DB, but others could also be defined and independently configured as well.

The model config is divided into sections which are further divided into the individual sources. We're going to start with the grid_params section which is where the list of columns to include for each source grid can be defined.

The special "include_colspec" setting defines the columns to include. A "colspec" is a list of wildcard strings, or globs, which match column names.

'Star' is the default, implied config, which matches all local columns, including relationship columns, as we just discussed.

Columns of remote tables, or joined columns, can also be defined using a dot-separated relationship path prefix.

For example, 'artistid.name' will include the Artist 'name' column in the Album grid, as joined through the 'artistid' relationship, which, again, is the name of the DBIC relationship that was automatically configured when we created the 'DB' model with the helper script, based on the foreign-key constraint in the underlying database schema.

Columns can also be joined across multiple levels. For example, albumid.artistid.*  will include all Artist columns in the Track grid, joined through the intermediate Album table. 

Now let's save our changes and restart the app

# Browser Demo

Let's look at the Track grid to see the joined columns we just enabled. 

These are the default, local columns, which are visible by default, but if we look at the available columns list, we can see that 3 more are also available. 

These are the columns from the Artist table. If we open the Artist grid we can compare. Because we specified a star in the colspec, it joined all 3 columns, and the relationship path is shown in the column header.

Notice, relationship columns can be joined like any other column. In this case, the multi-relationship "albums" is associated with the artist, not really the track. Dog Eat Dog has the Artist AC/DC, and AC/DC has 2 albums.

We also joined artistid.name in the album grid, so that column is also available, and, no surprise, the artist for these albums is AC/DC.

We know that the Track 'Dog Eat Dog' is in one of these albums. But, since we didn't join any of the Album columns, we can't see which one directly from the Track row. 

Well, we sort of can. We do have albumid, so we can see it belongs to albumid 4, which we can follow and see is "Let There Be Rock", or, just match artistid 4 back on the Album grid.

But, "album id 4" isn't very friendly or descriptive, and we don't want our users to have to memorize IDs. If we wanted to see the album title in the Track grid, we could always add it as another joined column. 

But, another way is to change which column from the related row is shown in the local relationship column, which we can also do. The default … display_column … is the primary key, albumid, but if we change it to 'title', "Let There Be Rock" will be displayed here instead of "4"

To do this we need to edit the RapidDbic config.

# Set display_columns

Again, we'll commit our changes, first, and then go back into the main class file.

We need to add another config section, TableSpecs, which, like grid_params, is sub-divided by result source.

'TableSpec' is a RapidApp-specific name for extra metadata associated with a result source, or table. Unlike the grid_params, which apply only to the grid interfaces, TableSpecs apply globally, to all locations and interfaces interacting with the source.

The 'display_column' defines which column should be used, by default, to represent a given row. It should be the name of a physical column in the table, and should be relatively short. The default is the first primary key column, or just the first column if there are no primary keys.

This setting affects relationship columns, and also other contexts, like dropdown lists and selections, as we'll see in just a bit.

As discussed, we're setting the display_column for Album to "title". While we're at it, let's set the display_column for a few other sources, too.

Now let's save our changes and start the app back up.

# Browser demo

To see the new config, we can refresh the browser, or, simply right-click and reload this tab.

As you can see, the albumid relationship column now shows the album title instead of the numeric id. We can also see the media and genre instead of ids because we set the display_column for those sources also.

One benefit of relationship columns over joined columns is the included link to the row. It is also simpler to configure and applies to multiple interfaces. 

The system understands the relationships for searching as well.

The Quick search applies to the displayed values, as you would expect, but you can also perform exact searches on relationships.

One of the condition types I haven't covered yet is the special 'is' condition, which allows selecting a specific related item among only the possible values.

With this filter, only Tracks with the Media Type "AAC audio file" will be shown, and this display string, once again, is set according to the display_column we configured for the MediaType source.

## TODO: demo searching count values on multi-rels 
##   -- RapidApp bug is blocking us!!

So far we've been working read-only….




For example, 
